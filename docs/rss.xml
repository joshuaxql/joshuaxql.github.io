<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Joshua's Blog</title><link>https://joshuaxql.github.io</link><description>Put wings on your dreams!</description><copyright>Joshua's Blog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/200189949?v=4</url><title>avatar</title><link>https://joshuaxql.github.io</link></image><lastBuildDate>Sat, 06 Dec 2025 03:57:02 +0000</lastBuildDate><managingEditor>Joshua's Blog</managingEditor><ttl>60</ttl><webMaster>Joshua's Blog</webMaster><item><title>neovim安装</title><link>https://joshuaxql.github.io/post/neovim-an-zhuang.html</link><description>&lt;img width='80' height='80' alt='Image' src='https://neovim.io/logos/neovim-mark-flat.png' /&gt;
&lt;img width='800' height='800' alt='Image' src='https://github.com/user-attachments/assets/0d053477-0350-4d29-a965-c8743a631ba1' &gt;

# 为什么选择neovim
~~当然是为了装杯啦!~~
- 相对来说neovim的配置肯定是更加复杂的，但也更加客制化。</description><guid isPermaLink="true">https://joshuaxql.github.io/post/neovim-an-zhuang.html</guid><pubDate>Sat, 06 Dec 2025 03:56:34 +0000</pubDate></item><item><title>ICS Lab1</title><link>https://joshuaxql.github.io/post/ICS%20Lab1.html</link><description># 完整代码
```
0011 0000 0000 0000    ; start at address x3000
0001 000 000 1 00000   ; ADD R0, R0, #0
0000 010 000000010     ; BRz ELSE
0001 000 001 1 00000   ; ADD R0, R1, #0
0000 111 000000001     ; BRnzp DONE
0001 000 010 1 00000   ; ELSE: ADD R0, R2, #0
1111 0000 0010 0101    ; DONE: HALT
```
# 代码讲解
## 逐条指令详细分析
### 指令1：设置条件码
```
0001 000 000 1 00000   ; ADD R0, R0, #0
```
- **操作码**: `0001` (ADD)
- **目标寄存器**: `000` (R0)
- **源寄存器**: `000` (R0)  
- **立即数模式**: `1`
- **立即数值**: `00000` (0)
- **功能**: 将 R0 的值与 0 相加，结果存回 R0
- **关键作用**: 虽然 R0 的值不变，但会根据其值设置条件码标志位(NZP)

### 指令2：条件分支
```
0000 010 000000010   ; BRz ELSE
```
- **操作码**: `0000` (BR)
- **条件码**: `010` (Z - 为零时分支)
- **PC偏移量**: `000000010` (2)
- **功能**: 如果上条指令设置的条件码显示为零(Z=1)，则跳转到 PC+2+2 = PC+4
- **计算**: 当前PC=x3001，目标地址=x3001+1+2=x3004

### 指令3：选择 val1
```
0001 000 001 1 00000   ; ADD R0, R1, #0
```
- **操作码**: `0001` (ADD)
- **目标寄存器**: `000` (R0)
- **源寄存器**: `001` (R1)
- **立即数模式**: `1`
- **立即数值**: `00000` (0)
- **功能**: 将 R1(val1) 的值复制到 R0
- **执行条件**: 当 cond=1 时执行此指令

### 指令4：无条件跳转
```
0000 111 000000001   ; BRnzp DONE
```
- **操作码**: `0000` (BR)
- **条件码**: `111` (nzp - 无条件分支)
- **PC偏移量**: `000000001` (1)
- **功能**: 无条件跳转到 PC+2+1 = PC+3
- **计算**: 当前PC=x3003，目标地址=x3003+1+1=x3005
- **目的**: 跳过 ELSE 部分，避免重复执行

### 指令5：选择 val2
```
0001 000 010 1 00000   ; ADD R0, R2, #0
```
- **操作码**: `0001` (ADD)
- **目标寄存器**: `000` (R0)
- **源寄存器**: `010` (R2)
- **立即数模式**: `1`
- **立即数值**: `00000` (0)
- **功能**: 将 R2(val2) 的值复制到 R0
- **执行条件**: 当 cond=0 时执行此指令

### 指令6：程序终止
```
1111 000000100101   ; TRAP x25
```
- **操作码**: `1111` (TRAP)
- **陷阱向量**: `000000100101` (x25)
- **功能**: 调用系统陷阱服务程序，x25 对应 HALT 指令
- **作用**: 正常终止程序执行

## 内存地址布局

| 地址 | 指令 | 标签 | 功能 |
|------|------|------|------|
| x3000 | ADD R0, R0, #0 | - | 设置条件码 |
| x3001 | BRz ELSE | - | 条件分支 |
| x3002 | ADD R0, R1, #0 | - | 选择 val1 |
| x3003 | BRnzp DONE | - | 跳过 ELSE |
| x3004 | ADD R0, R2, #0 | ELSE | 选择 val2 |
| x3005 | TRAP x25 | DONE | 程序终止 |

## 执行路径分析

### 情况1: cond = 1 (R0 = 1)
```
x3000: ADD R0, R0, #0  // R0=1, 设置P(正数)标志
x3001: BRz ELSE        // Z=0, 不跳转，继续执行
x3002: ADD R0, R1, #0  // R0 ← R1 (选择val1)
x3003: BRnzp DONE      // 无条件跳转到x3005
x3005: TRAP x25        // 程序终止
```
**结果**: R0 = val1

### 情况2: cond = 0 (R0 = 0)
```
x3000: ADD R0, R0, #0  // R0=0, 设置Z(零)标志
x3001: BRz ELSE        // Z=1, 跳转到x3004
x3004: ADD R0, R2, #0  // R0 ← R2 (选择val2)
x3005: TRAP x25        // 程序终止
```
**结果**: R0 = val2。</description><guid isPermaLink="true">https://joshuaxql.github.io/post/ICS%20Lab1.html</guid><pubDate>Fri, 05 Dec 2025 17:17:12 +0000</pubDate></item><item><title>ICS Lab2</title><link>https://joshuaxql.github.io/post/ICS%20Lab2.html</link><description>## 完整的LC3代码
```asm
            .ORIG x3000
MAIN        LDI R1, N               ; 从x3100加载N到R1
            ADD R0, R1, #-2        ; 检查N是否小于等于2
            BRnz BASE_CASE         ; 如果是，跳转到基本情况
            
            ; 初始化数组
            LEA R2, Q_ARRAY        ; R2指向Q数组
            AND R0, R0, #0
            ADD R0, R0, #1         ; R0 = 1
            STR R0, R2, #0         ; Q[1] = 1
            STR R0, R2, #1         ; Q[2] = 1
            
            ; 开始计算Q(3)到Q(N)
            AND R3, R3, #0
            ADD R3, R3, #3         ; R3 = i = 3
            
LOOP        NOT R4, R3
            ADD R4, R4, #1         ; R4 = -i
            ADD R4, R1, R4         ; R4 = N - i
            BRn END_LOOP           ; 如果i &gt; N，结束循环
            
            ; 计算i - Q(i-1)
            ADD R4, R3, #-1        ; R4 = i-1
            ADD R4, R4, R2         ; R4指向Q[i-1]
            LDR R5, R4, #-1         ; R5 = Q(i-1)
            NOT R5, R5
            ADD R5, R5, #1         ; R5 = -Q(i-1)
            ADD R4, R3, R5         ; R4 = i - Q(i-1) = index1
            
            ; 获取Q(index1)
            ADD R5, R4, R2         ; R5指向Q[index1]
            LDR R5, R5, #-1        ; R5 = Q[index1] (数组索引从0开始)
            
            ; 计算i - Q(i-2)
            ADD R4, R3, #-2        ; R4 = i-2
            ADD R4, R4, R2         ; R4指向Q[i-2]
            LDR R6, R4, #-1         ; R6 = Q(i-2)
            NOT R6, R6
            ADD R6, R6, #1         ; R6 = -Q(i-2)
            ADD R4, R3, R6         ; R4 = i - Q(i-2) = index2
            
            ; 获取Q(index2)
            ADD R6, R4, R2         ; R6指向Q[index2]
            LDR R6, R6, #-1        ; R6 = Q[index2]
            
            ; 计算Q(i) = Q(index1) + Q(index2)
            ADD R5, R5, R6         ; R5 = Q(i)
            
            ; 存储Q(i)
            ADD R4, R3, #-1        ; R4 = i-1 (数组索引)
            ADD R4, R4, R2         ; R4指向Q[i]
            STR R5, R4, #0         ; 存储Q(i)
            
            ; 检查是否达到N
            NOT R4, R3
            ADD R4, R4, #1         ; R4 = -i
            ADD R4, R1, R4         ; R4 = N - i
            BRnp NEXT_ITER         ; 如果i != N，继续循环
            
            ; i == N，保存结果到R7
            ADD R7, R5, #0         ; R7 = Q(N)
            
NEXT_ITER   ADD R3, R3, #1         ; i = i + 1
            BR LOOP
            
END_LOOP    ; 将结果存储到x3101
            LD R0, RESULT_ADDR
            STR R7, R0, #0
            HALT

BASE_CASE   ; 基本情况：N=1或2时，Q(N)=1
            LD R0, RESULT_ADDR
            AND R1, R1, #0
            ADD R1, R1, #1
            STR R1, R0, #0         ; 存储1到x3101
            HALT

N           .FILL x3100           ; 输入N的地址
RESULT_ADDR .FILL x3101           ; 输出结果的地址
Q_ARRAY     .BLKW 100             ; Q数组，存储Q[1]到Q[100]

            .END
```
## 关于代码的分析
### 1 程序结构
我的实现遵循参考方法，包含以下关键部分：

1. **内存组织：**
   - 输入 `N` 存储在内存地址 `x3100`
   - 输出 `Q(N)` 存储在内存地址 `x3101`
   - 数组 `Q[1..100]` 在程序末尾分配（使用 `.BLKW 100`）

2. **主要算法：**
   - 检查基本情况：如果 `N ≤ 2`，返回 `Q(N) = 1`
   - 初始化 `Q[1] = 1` 和 `Q[2] = 1`
   - 对于 `i = 3` 到 `N`：
     - 计算 `index1 = i - Q(i-1)`
     - 计算 `index2 = i - Q(i-2)`
     - 设置 `Q(i) = Q(index1) + Q(index2)`
   - 将 `Q(N)` 存储到 `x3101`

### 2 使用的寻址模式
- **PC相对寻址：** 用于加载常量和标签（如 `LD R1, N`）
- **基址+偏移寻址：** 用于使用 `LEA` 和偏移量访问数组
- **间接寻址：** 用于访问 `x3100` 和 `x3101` 处的内存位置

### 3 内存管理
Q数组使用100个连续的内存字来模拟。</description><guid isPermaLink="true">https://joshuaxql.github.io/post/ICS%20Lab2.html</guid><pubDate>Fri, 05 Dec 2025 17:05:48 +0000</pubDate></item></channel></rss>